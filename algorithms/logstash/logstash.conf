input{
    jdbc{
        jdbc_driver_library => "/usr/share/logstash/logstash-core/lib/jars/postgresql-42.7.3.jar"
        jdbc_driver_class => "org.postgresql.Driver"
        jdbc_connection_string => "jdbc:postgresql://postgresql:5432/${POSTGRES_DB}"
        jdbc_user => "${POSTGRES_USER}"
        jdbc_password => "${POSTGRES_PASSWORD}"
        jdbc_paging_enabled => true
        jdbc_page_size => 10000
        use_column_value => true
        tracking_column => "last_updated_at"
        tracking_column_type => "timestamp"
        schedule => "*/1 * * * * *" # e.g. 2 minutes, see https://crontab.cronhub.io/
        statement => 'SELECT user_id, username, st_x(lat_long)::float as lat, st_y(lat_long)::float as lon, location, joining_date, items_sold, items_purchased, see_charity, last_updated_at FROM public."Users" WHERE last_updated_at > :sql_last_value AND last_updated_at < CURRENT_TIMESTAMP ORDER BY user_id'
        type => "users"
        last_run_metadata_path => "/usr/share/logstash/pipeline/.users"
    }
    jdbc{
        jdbc_driver_library => "/usr/share/logstash/logstash-core/lib/jars/postgresql-42.7.3.jar"
        jdbc_driver_class => "org.postgresql.Driver"
        jdbc_connection_string => "jdbc:postgresql://postgresql:5432/${POSTGRES_DB}"
        jdbc_user => "${POSTGRES_USER}"
        jdbc_password => "${POSTGRES_PASSWORD}"
        jdbc_paging_enabled => true
        jdbc_page_size => 10000
        use_column_value => true
        tracking_column => "last_updated_at"
        tracking_column_type => "timestamp"
        schedule => "*/1 * * * * *"
        statement => 'SELECT listing_id, seller_id, buyer_username, title, price, st_x(lat_long)::float as lat, st_y(lat_long)::float as lon, location, status, listed_at, last_updated_at, category, for_charity FROM public."Listings" WHERE last_updated_at > :sql_last_value AND last_updated_at < CURRENT_TIMESTAMP ORDER BY listing_id'
        type => "listings"
        last_run_metadata_path => "/usr/share/logstash/pipeline/.listings"
    }
}

filter{
    mutate {
        convert => {
            "lat" => "float"
            "lon" => "float"
        }
        rename => {
            "lat" => "[lat_long][lat]"
            "lon" => "[lat_long][lon]"
        }
    }
    if [type] == "users" {
        clone {
            clones => ["neo4j-users"]
            ecs_compatibility => disabled
        }
        mutate {
            copy => {"user_id" => "[@metadata][_id]"}
            remove_field => ["@version", "@timestamp"]
        }
        if [type] == "neo4j-users" {
            ruby {
                code => 'event.set("statements", [{"statement" => "MERGE (u:User {id: #{event.get("user_id")}}) MERGE (p:PostalCode {id: \'#{event.get("location")}\'}) MERGE (u)-[:nearby {rating: 3}]->(p)"}])'
            }
            mutate {
                remove_field => [ "user_id", "username", "lat_long", "location", "joining_date", "items_sold", "items_purchased", "see_charity", "last_updated_at", "type" ]
            }
        }
    }
    if [type] == "listings" {
        clone {
            clones => ["neo4j-listings"]
            ecs_compatibility => disabled
        }
        mutate {
            copy => {"listing_id" => "[@metadata][_id]"}
            remove_field => ["@version", "@timestamp"]
        }
        if [type] == "neo4j-listings" {
            ruby {
                code => 'event.set("statements", [{"statement" => "MERGE (l:Listing {id: #{event.get("listing_id")}}) MERGE (p:PostalCode {id: \'#{event.get("location")}\'}) MERGE (u)-[:nearby {rating: 3}]->(p)"}, {"statement" => "MERGE (u:User {id: #{event.get("seller_id")}}) MERGE (l:Listing {id: #{event.get("listing_id")}}) MERGE (u)-[:HISTORY {rating: 3}]->(l)"}])'
            }
            mutate {
                remove_field => [ "listing_id", "seller_id", "buyer_username", "title", "price", "lat_long", "location", "status", "listed_at", "last_updated_at", "category", "for_charity", "type" ]
            }
        }
    } 
}

output{
    if [type] == "users" {
        elasticsearch{
            index => "users"
            document_id => "%{[@metadata][_id]}"
            hosts => "${ELASTIC_HOSTS}"
            user => "${ELASTIC_USER}"
            password => "${ELASTIC_PASSWORD}"
            cacert => "certs/ca/ca.crt"
            template => "/usr/share/logstash/pipeline/dynamic-template.json"
            template_name => "geo_point_pattern"
            template_overwrite => true
            upsert => true
        }
    }
    else if [type] == "listings" {
        elasticsearch{
            index => "listings"
            document_id => "%{[@metadata][_id]}"
            hosts => "${ELASTIC_HOSTS}"
            user => "${ELASTIC_USER}"
            password => "${ELASTIC_PASSWORD}"
            cacert => "certs/ca/ca.crt"
            template => "/usr/share/logstash/pipeline/dynamic-template.json"
            template_name => "geo_point_pattern"
            template_overwrite => true
            upsert => true
        }
    }
    else {
        http {
            url => "http://neo4j:7474/db/neo4j/tx/commit"
            http_method => "post"
            headers => {
                "Authorization" => "Basic bmVvNGo6bmVvNGpfJDNuZzQ5OQ=="
                "Content-Type" => "application/json"
            }
            automatic_retries => 3
        }
        stdout { codec => json }
    }
}